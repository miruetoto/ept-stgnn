<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.533">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>. - 250225-6-1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">.</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">250225-6-1</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="section" class="level1">
<h1>250225-6-1</h1>
<section id="load" class="level2">
<h2 class="anchored" data-anchor-id="load">1. Load</h2>
<div id="cell-2" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pickle</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-3" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># .pkl 파일에서 불러오기</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"./data/data.pkl"</span>, <span class="st">"rb"</span>) <span class="im">as</span> f:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    data_loaded <span class="op">=</span> pickle.load(f)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 변수 개별 할당</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data_loaded[<span class="st">"y"</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>yU <span class="op">=</span> data_loaded[<span class="st">"yU"</span>]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>yP <span class="op">=</span> data_loaded[<span class="st">"yP"</span>]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> data_loaded[<span class="st">"t"</span>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>regions <span class="op">=</span> data_loaded[<span class="st">"regions"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="모든-일사량-자료를-시각화" class="level2">
<h2 class="anchored" data-anchor-id="모든-일사량-자료를-시각화">2. 모든 일사량 자료를 시각화</h2>
<p>태풍 힌남노는 2022년 9월 4일에 발생하여 9월 7일까지 영향을 미쳤습니다. 주로 한반도와 일본, 중국 근처를 지나면서 강한 바람과 비를 동반했죠. 실제로 한국에서는 많은 피해가 있었고, 특히 경상도 지역에 큰 영향을 미쳤습니다.</p>
<p><a href="https://namu.wiki/w/%ED%9E%8C%EB%82%A8%EB%85%B8" class="uri">https://namu.wiki/w/%ED%9E%8C%EB%82%A8%EB%85%B8</a></p>
<p>Cluster 1: Wonju, Seosan, Cheongju, Hongseong</p>
<p>Cluster 2: Daegwallyeong, Bukgangneung, Gangneung, Ulleungdo</p>
<p>Cluster 3: Bukchoncheon, Cheorwon, Chuncheon, Seoul, Incheon, Suwon</p>
<p>Cluster 4: Baengnyeongdo</p>
<p>Cluster 5: Heuksando, Jeju, Gosan</p>
<p>Cluster 6: Changwon, Busan, Yeouido, Jinju, Gimhae-si, Bukchangwon, Yangsan-si, Uiryeong-gun, Hamyang-gun, Gwangyang-si</p>
<p>Cluster 7: Gwangju, Mokpo, Gochang, Gochang-gun, Yeonggwang-gun, Boseong-gun, Gangjin-gun</p>
<p>Cluster 8: Daejeon, Andong, Jeonju</p>
<p>Cluster 9: Chupungnyeong, Pohang, Daegu, Sunchang-gun, Cheongsong-gun, Gyeongju-si</p>
<p>클러스터 2,3,7,8 에 해당하는 도시들의 인덱스..</p>
<div id="cell-8" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">20</span>, <span class="dv">22</span>, <span class="dv">24</span>, <span class="dv">27</span>, <span class="dv">30</span>, <span class="dv">33</span>, <span class="dv">35</span>, <span class="dv">36</span>, <span class="dv">39</span>, <span class="dv">40</span>, <span class="dv">41</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(idx)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>20</code></pre>
</div>
</div>
<div id="cell-9" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 예제 데이터를 생성</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="st">"2022-09-01"</span>, end<span class="op">=</span><span class="st">"2022-09-15"</span>, freq<span class="op">=</span><span class="st">"H"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 지역명을 생성 (예시: "Location 1", "Location 2", ..., "Location 44")</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>region_names <span class="op">=</span> regions</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 9월 1일부터 9월 15일까지의 데이터 필터링</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>start_date <span class="op">=</span> <span class="st">"2022-09-01"</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>end_date <span class="op">=</span> <span class="st">"2022-09-15"</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>filtered_t <span class="op">=</span> t[(t <span class="op">&gt;=</span> start_date) <span class="op">&amp;</span> (t <span class="op">&lt;=</span> end_date)]</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>filtered_y <span class="op">=</span> y[(t <span class="op">&gt;=</span> start_date) <span class="op">&amp;</span> (t <span class="op">&lt;=</span> end_date), :]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 클러스터 3, 6, 7 정의</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>cluster_3 <span class="op">=</span> {<span class="st">'Bukchoncheon'</span>, <span class="st">'Cheorwon'</span>, <span class="st">'Chuncheon'</span>, <span class="st">'Seoul'</span>, <span class="st">'Incheon'</span>, <span class="st">'Suwon'</span>}</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>cluster_6 <span class="op">=</span> {<span class="st">'Changwon'</span>, <span class="st">'Busan'</span>, <span class="st">'Yeouido'</span>, <span class="st">'Jinju'</span>, <span class="st">'Gimhae-si'</span>, <span class="st">'Bukchangwon'</span>, </span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>             <span class="st">'Yangsan-si'</span>, <span class="st">'Uiryeong-gun'</span>, <span class="st">'Hamyang-gun'</span>}</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>cluster_7 <span class="op">=</span> {<span class="st">'Gwangju'</span>, <span class="st">'Mokpo'</span>, <span class="st">'Gochang'</span>, <span class="st">'Gochang-gun'</span>, <span class="st">'Yeonggwang-gun'</span>}</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="co"># 클러스터별 배경색 지정</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>cluster_colors <span class="op">=</span> {</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cluster_3"</span>: <span class="st">"#DDFFDD"</span>,  <span class="co"># 연한 초록색</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cluster_6"</span>: <span class="st">"#DDDDFF"</span>,  <span class="co"># 연한 파란색</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cluster_7"</span>: <span class="st">"#FFDDFF"</span>   <span class="co"># 연한 분홍색</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co"># 클러스터 3, 6, 7에 해당하는 지역 인덱스 찾기</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>selected_indices <span class="op">=</span> [i <span class="cf">for</span> i, city <span class="kw">in</span> <span class="bu">enumerate</span>(region_names) <span class="cf">if</span> city <span class="kw">in</span> cluster_3 <span class="kw">or</span> city <span class="kw">in</span> cluster_6 <span class="kw">or</span> city <span class="kw">in</span> cluster_7]</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>selected_regions <span class="op">=</span> [region_names[i] <span class="cf">for</span> i <span class="kw">in</span> selected_indices]</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="co"># 서브플롯 설정 (5행 4열)</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">5</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">7</span>))</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.flatten()  <span class="co"># 2D 배열을 1D 배열로 변환</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="co"># y축 범위 설정 (filtered_y 데이터의 전체 최소/최대 값 사용)</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>y_min, y_max <span class="op">=</span> np.<span class="bu">min</span>(filtered_y), np.<span class="bu">max</span>(filtered_y)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 지역에 대해 시계열 그래프 그리기</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, region_idx <span class="kw">in</span> <span class="bu">enumerate</span>(selected_indices):  </span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    region_name <span class="op">=</span> selected_regions[i]</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 해당 지역이 속한 클러스터에 따라 배경색 설정</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> region_name <span class="kw">in</span> cluster_3:</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        axes[i].patch.set_facecolor(cluster_colors[<span class="st">"cluster_3"</span>])</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> region_name <span class="kw">in</span> cluster_6:</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        axes[i].patch.set_facecolor(cluster_colors[<span class="st">"cluster_6"</span>])</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> region_name <span class="kw">in</span> cluster_7:</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>        axes[i].patch.set_facecolor(cluster_colors[<span class="st">"cluster_7"</span>])</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 시계열 데이터 플로팅</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    axes[i].plot(filtered_t, filtered_y[:, region_idx], color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>    axes[i].set_title(region_name, fontsize<span class="op">=</span><span class="dv">10</span>)  <span class="co"># 글씨 크기 축소</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># y축 값을 고정</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    axes[i].set_ylim(y_min, y_max)</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># x축, y축 라벨 생략</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    axes[i].set_yticklabels([])</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>    axes[i].set_xticklabels([])</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a><span class="co"># 그래프 레이아웃 조정</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a><span class="co"># 저장 경로 설정</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>save_path <span class="op">=</span> <span class="st">"./figs/cluster_3_6_7_plot.pdf"</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>os.makedirs(os.path.dirname(save_path), exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>plt.savefig(save_path, <span class="bu">format</span><span class="op">=</span><span class="st">"pdf"</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a><span class="co"># 그래프 출력</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="250225-6-Plots-1_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>서울만 플랏!</p>
<div id="cell-11" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.dates <span class="im">as</span> mdates</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># LaTeX 스타일 폰트 설정</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update({</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"text.usetex"</span>: <span class="va">True</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"font.family"</span>: <span class="st">"serif"</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 예제 데이터를 생성</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="st">"2022-09-01"</span>, end<span class="op">=</span><span class="st">"2022-09-15"</span>, freq<span class="op">=</span><span class="st">"H"</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 지역명을 생성 (예시: "Location 1", "Location 2", ..., "Location 44")</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>region_names <span class="op">=</span> regions</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 9월 1일부터 9월 15일까지의 데이터 필터링</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>start_date <span class="op">=</span> <span class="st">"2022-09-01"</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>end_date <span class="op">=</span> <span class="st">"2022-09-15"</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>filtered_t <span class="op">=</span> t[(t <span class="op">&gt;=</span> start_date) <span class="op">&amp;</span> (t <span class="op">&lt;=</span> end_date)]</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>filtered_y <span class="op">=</span> y[(t <span class="op">&gt;=</span> start_date) <span class="op">&amp;</span> (t <span class="op">&lt;=</span> end_date), :]</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 서울만 선택</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>selected_region <span class="op">=</span> <span class="st">"Seoul"</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>selected_index <span class="op">=</span> region_names.index(selected_region)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="co"># 클러스터별 배경색 지정</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>cluster_colors <span class="op">=</span> {</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cluster_3"</span>: <span class="st">"#DDFFDD"</span>,  <span class="co"># 연한 초록색</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cluster_6"</span>: <span class="st">"#DDDDFF"</span>,  <span class="co"># 연한 파란색</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cluster_7"</span>: <span class="st">"#FFDDFF"</span>   <span class="co"># 연한 분홍색</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 서울이 속한 클러스터 찾기</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>seoul_cluster <span class="op">=</span> <span class="va">None</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> selected_region <span class="kw">in</span> {<span class="st">'Bukchoncheon'</span>, <span class="st">'Cheorwon'</span>, <span class="st">'Chuncheon'</span>, <span class="st">'Seoul'</span>, <span class="st">'Incheon'</span>, <span class="st">'Suwon'</span>}:</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    seoul_cluster <span class="op">=</span> <span class="st">"cluster_3"</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> selected_region <span class="kw">in</span> {<span class="st">'Changwon'</span>, <span class="st">'Busan'</span>, <span class="st">'Yeouido'</span>, <span class="st">'Jinju'</span>, <span class="st">'Gimhae-si'</span>, <span class="st">'Bukchangwon'</span>, <span class="st">'Yangsan-si'</span>, <span class="st">'Uiryeong-gun'</span>, <span class="st">'Hamyang-gun'</span>, <span class="st">'Gwangyang-si'</span>}:</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    seoul_cluster <span class="op">=</span> <span class="st">"cluster_6"</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> selected_region <span class="kw">in</span> {<span class="st">'Gwangju'</span>, <span class="st">'Mokpo'</span>, <span class="st">'Gochang'</span>, <span class="st">'Gochang-gun'</span>, <span class="st">'Yeonggwang-gun'</span>, <span class="st">'Boseong-gun'</span>, <span class="st">'Gangjin-gun'</span>}:</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    seoul_cluster <span class="op">=</span> <span class="st">"cluster_7"</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a><span class="co"># 그래프 설정 (해상도 높게 저장)</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">3</span>), dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> seoul_cluster:</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    ax.set_facecolor(cluster_colors[seoul_cluster])  <span class="co"># 배경색 설정</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="co"># 시계열 데이터 플로팅</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>ax.plot(filtered_t, filtered_y[:, selected_index], color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="vs">r"Seoul Solar Radiation"</span>, fontsize<span class="op">=</span><span class="dv">11</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)  <span class="co"># 제목 조정</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a><span class="co"># x축, y축 라벨 변경 및 설정</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r"Date"</span>, fontsize<span class="op">=</span><span class="dv">10</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r"Solar Radiation"</span>, fontsize<span class="op">=</span><span class="dv">10</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a><span class="co"># x축 날짜 포맷 조정 (가장 짧은 en-dash 사용 YYYY–MM–DD.)</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(mdates.DateFormatter(<span class="st">"%Y–%m–</span><span class="sc">%d</span><span class="st">"</span>))</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_locator(mdates.DayLocator(interval<span class="op">=</span><span class="dv">2</span>))  <span class="co"># 2일 간격으로 표시</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">0</span>, fontsize<span class="op">=</span><span class="dv">9</span>)</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">9</span>)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a><span class="co"># 그리드 추가</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>ax.grid(<span class="va">True</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a><span class="co"># 저장 경로 설정</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>save_path <span class="op">=</span> <span class="st">"./figs/seoul_solar_radiation.pdf"</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>os.makedirs(os.path.dirname(save_path), exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>plt.savefig(save_path, <span class="bu">format</span><span class="op">=</span><span class="st">"pdf"</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a><span class="co"># 그래프 출력</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="250225-6-Plots-1_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solar Radiation Prediction Using Spatio-Temporal Graph Neural Networks
</div>
</div>
<div class="callout-body-container callout-body">
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1. Introduction</h2>
<p>This report presents an analysis of solar radiation data, starting with an examination of solar radiation in Seoul, followed by an exploration of how spatial information can enhance forecasting accuracy. Two key visualizations are used: 1. <strong>Seoul Solar Radiation Time Series</strong> 2. <strong>Clustered Solar Radiation Time Series Across Multiple Locations</strong></p>
</section>
<section id="solar-radiation-in-seoul" class="level2">
<h2 class="anchored" data-anchor-id="solar-radiation-in-seoul">2. Solar Radiation in Seoul</h2>
<p>The first figure (Seoul Solar Radiation Time Series) illustrates the variations in solar radiation in Seoul over time. This data exhibits typical characteristics of a time series, including daily cyclic patterns, which are crucial for understanding and predicting solar energy generation.</p>
<p>Understanding and forecasting solar radiation is fundamental for predicting solar power generation, as solar energy is directly proportional to radiation intensity. Reliable solar radiation forecasting enables better energy management, grid stability, and optimization of energy storage systems.</p>
</section>
<section id="traditional-time-series-prediction-approaches" class="level2">
<h2 class="anchored" data-anchor-id="traditional-time-series-prediction-approaches">3. Traditional Time Series Prediction Approaches</h2>
<p>Predicting solar radiation can be approached as a classical time series forecasting problem. Various time series models have been developed for such tasks, including: - <strong>Autoregressive Integrated Moving Average (ARIMA) [1]</strong> - <strong>Long Short-Term Memory (LSTM) networks [2]</strong> - <strong>Temporal Convolutional Networks (TCN) [3]</strong> - <strong>Transformer-based time series models [4]</strong></p>
<p>The fundamental idea behind time series forecasting is that the value at time <strong>t</strong> depends on past observations. By analyzing historical patterns, these models attempt to predict future values.</p>
</section>
<section id="expanding-beyond-a-single-location-spatio-temporal-analysis" class="level2">
<h2 class="anchored" data-anchor-id="expanding-beyond-a-single-location-spatio-temporal-analysis">4. Expanding Beyond a Single Location: Spatio-Temporal Analysis</h2>
<p>While traditional time series models consider only historical values of a single location, real-world solar radiation data includes multiple locations with similar weather patterns. The second figure (Clustered Solar Radiation Time Series Across Multiple Locations) shows the time series patterns for multiple locations grouped by similarity.</p>
<ul>
<li>Locations in <strong>Cluster 3</strong> (e.g., Seoul, Incheon, Suwon) exhibit similar temporal patterns.</li>
<li>Cluster-based grouping is done based on visually identified similarities in solar radiation trends.</li>
<li>These regions share similar geographical and meteorological conditions.</li>
</ul>
<p>To enhance the prediction of solar radiation for Seoul at time <strong>t</strong>, it is beneficial to incorporate not only Seoul’s past values but also those from similar regions (e.g., Cluster 3 locations).</p>
</section>
<section id="spatio-temporal-graph-neural-networks-stgnn" class="level2">
<h2 class="anchored" data-anchor-id="spatio-temporal-graph-neural-networks-stgnn">5. Spatio-Temporal Graph Neural Networks (STGNN)</h2>
<p>Instead of treating solar radiation as an independent time series for each location, our approach views it as <strong>spatio-temporal data</strong>—where each location is a node in a graph, connected to other relevant locations.</p>
<p>Spatio-temporal graph neural networks (STGNNs) effectively capture spatial dependencies between locations while modeling temporal dependencies. These models combine: - <strong>Graph Convolutional Networks (GCNs) [5]</strong> for capturing spatial relationships - <strong>Recurrent or Transformer-based models [6]</strong> for modeling temporal dependencies</p>
</section>
<section id="key-contributions-of-our-approach" class="level2">
<h2 class="anchored" data-anchor-id="key-contributions-of-our-approach">6. Key Contributions of Our Approach</h2>
<p>Our proposed method extends traditional STGNN-based solar radiation forecasting in the following ways:</p>
<ol type="1">
<li><strong>Learned Graph Structure</strong>: Unlike most STGNN models that assume a pre-defined adjacency matrix, we infer the spatial relationships from data.</li>
<li><strong>Decomposed Signal Representation</strong>: We express solar radiation as the product of: [ = ] This allows us to model different aspects of solar radiation separately.</li>
<li><strong>Ensemble Patch Transform (EPT)</strong>: This decomposition is achieved via an ensemble patch transform, enabling us to:
<ul>
<li>Estimate periodic components using all available locations.</li>
<li>Estimate amplitude variations using only highly relevant locations.</li>
</ul></li>
<li><strong>Greater Model Flexibility</strong>: By decomposing the signal, we can integrate different types of predictive models for each component, leading to improved generalization.</li>
</ol>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">7. Conclusion</h2>
<p>This study proposes a novel <strong>spatio-temporal deep learning approach</strong> for solar radiation forecasting, combining time series analysis with spatial information. The approach provides: - Better predictive performance by leveraging spatial dependencies - A more interpretable model structure using decomposed signal components</p>
<p>Future work includes validating this approach on large-scale datasets and integrating additional meteorological variables.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>[1] Box, G. E. P., Jenkins, G. M., &amp; Reinsel, G. C. (2015). <em>Time Series Analysis: Forecasting and Control.</em></p>
<p>[2] Hochreiter, S., &amp; Schmidhuber, J. (1997). <em>Long Short-Term Memory.</em> Neural Computation.</p>
<p>[3] Bai, S., Kolter, J. Z., &amp; Koltun, V. (2018). <em>An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling.</em></p>
<p>[4] Vaswani, A., et al.&nbsp;(2017). <em>Attention Is All You Need.</em> NeurIPS.</p>
<p>[5] Kipf, T. N., &amp; Welling, M. (2016). <em>Semi-Supervised Classification with Graph Convolutional Networks.</em></p>
<p>[6] Wu, Z., et al.&nbsp;(2019). <em>Graph WaveNet for Deep Spatial-Temporal Graph Modeling.</em></p>
</section>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
태양 복사량 예측을 위한 시공간 그래프 신경망 (STGNN)
</div>
</div>
<div class="callout-body-container callout-body">
<section id="서론" class="level2">
<h2 class="anchored" data-anchor-id="서론">1. 서론</h2>
<p>이 보고서는 태양 복사량 데이터를 분석하고, 공간 정보를 활용하여 예측 정확도를 향상시키는 방법을 설명합니다. 이를 위해 두 개의 주요 시각적 자료를 활용합니다. 1. <strong>서울 태양 복사량 시계열 그래프</strong> 2. <strong>다양한 위치에서의 태양 복사량 시계열 그래프 (클러스터 기반 그룹화)</strong></p>
</section>
<section id="서울의-태양-복사량" class="level2">
<h2 class="anchored" data-anchor-id="서울의-태양-복사량">2. 서울의 태양 복사량</h2>
<p>첫 번째 그림(서울 태양 복사량 시계열 그래프)은 서울에서의 태양 복사량 변화를 시간에 따라 나타냅니다. 해당 데이터는 하루 단위 주기를 포함하는 전형적인 시계열 패턴을 보이며, 이는 태양광 발전량 예측에 있어 중요한 요소입니다.</p>
<p>태양광 발전량을 예측하기 위해서는 태양 복사량을 정확히 예측하는 것이 필수적입니다. 태양광 발전량은 태양 복사량에 직접적으로 비례하며, 정확한 예측은 에너지 관리, 전력망 안정성, 에너지 저장 시스템 최적화 등에 도움이 됩니다.</p>
</section>
<section id="전통적인-시계열-예측-기법" class="level2">
<h2 class="anchored" data-anchor-id="전통적인-시계열-예측-기법">3. 전통적인 시계열 예측 기법</h2>
<p>태양 복사량 예측은 전형적인 시계열 분석 문제로 간주될 수 있으며, 이를 해결하기 위해 다양한 방법이 존재합니다. - <strong>ARIMA (AutoRegressive Integrated Moving Average) [1]</strong> - <strong>LSTM (Long Short-Term Memory) 신경망 [2]</strong> - <strong>TCN (Temporal Convolutional Networks) [3]</strong> - <strong>트랜스포머 기반 시계열 모델 [4]</strong></p>
<p>시계열 예측의 기본 원리는 <strong>현재 시점 t의 값을 예측하기 위해 t 이전의 데이터를 활용</strong>하는 것입니다.</p>
</section>
<section id="시공간-데이터로-확장" class="level2">
<h2 class="anchored" data-anchor-id="시공간-데이터로-확장">4. 시공간 데이터로 확장</h2>
<p>기존 시계열 분석은 단일 위치의 데이터만 고려하는 반면, 실제 태양 복사량 데이터는 다양한 지역에서 측정됩니다. 두 번째 그림(클러스터 기반 태양 복사량 시계열 그래프)은 여러 지역의 패턴을 그룹화하여 보여줍니다.</p>
<ul>
<li><strong>Cluster 3 (서울, 인천, 수원 등)</strong></li>
<li>클러스터 내 지역들은 유사한 시계열 패턴을 보이며, 동일한 기상 조건을 공유할 가능성이 큽니다.</li>
<li>따라서 서울의 태양 복사량 예측을 위해서는 서울뿐만 아니라 유사한 패턴을 가진 주변 지역의 정보도 함께 고려해야 합니다.</li>
</ul>
</section>
<section id="시공간-그래프-신경망-stgnn" class="level2">
<h2 class="anchored" data-anchor-id="시공간-그래프-신경망-stgnn">5. 시공간 그래프 신경망 (STGNN)</h2>
<p>태양 복사량을 단순한 시계열 데이터로 보는 것이 아니라, <strong>시공간(spatio-temporal) 데이터</strong>로 해석할 수 있습니다. 즉, 각 위치를 그래프의 노드로 간주하고, 서로 유사한 지역을 연결하여 예측 정확도를 높일 수 있습니다.</p>
<p>STGNN은 다음과 같은 두 가지 요소를 결합하여 공간적, 시간적 관계를 동시에 모델링합니다. - <strong>그래프 합성곱 네트워크 (GCN) [5]</strong>: 공간적 의존성 모델링 - <strong>순환 신경망 또는 트랜스포머 기반 모델 [6]</strong>: 시간적 패턴 학습</p>
</section>
<section id="연구의-주요-기여" class="level2">
<h2 class="anchored" data-anchor-id="연구의-주요-기여">6. 연구의 주요 기여</h2>
<p>본 연구에서는 기존 STGNN 모델을 확장하여 다음과 같은 차별점을 둡니다.</p>
<ol type="1">
<li><strong>학습된 그래프 구조</strong>: 기존 연구에서는 노드 간 연결을 사전에 정의하지만, 우리는 데이터를 통해 공간적 관계를 학습합니다.</li>
<li><strong>신호 분해 기법 적용</strong>: 태양 복사량을 다음과 같이 분해하여 각각의 요소를 분석합니다. [ = ]</li>
<li><strong>Ensemble Patch Transform (EPT) 기법 활용</strong>:
<ul>
<li>주기 성분은 전체 노드 정보를 활용하여 추정</li>
<li>진폭 변조 성분은 관련성이 높은 일부 노드만 활용하여 추정</li>
</ul></li>
<li><strong>모델 조합의 유연성</strong>: 원래 신호를 단순한 신호들의 곱으로 분해하여, 다양한 예측 모델을 효과적으로 결합할 수 있도록 합니다.</li>
</ol>
</section>
<section id="결론" class="level2">
<h2 class="anchored" data-anchor-id="결론">7. 결론</h2>
<p>본 연구는 <strong>시계열 분석과 공간 정보를 결합</strong>하여 태양 복사량을 더욱 효과적으로 예측하는 접근법을 제시합니다. 이를 통해: - <strong>공간적 의존성을 활용하여 예측 성능을 향상</strong> - <strong>신호 분해를 통해 모델의 해석 가능성을 높임</strong></p>
<p>향후 연구에서는 대규모 데이터셋을 활용한 검증 및 기상 조건을 추가 변수로 고려하는 방안을 탐색할 예정입니다.</p>
</section>
<section id="참고-문헌" class="level2">
<h2 class="anchored" data-anchor-id="참고-문헌">참고 문헌</h2>
<p>[1] Box, G. E. P., Jenkins, G. M., &amp; Reinsel, G. C. (2015). <em>Time Series Analysis: Forecasting and Control.</em></p>
<p>[2] Hochreiter, S., &amp; Schmidhuber, J. (1997). <em>Long Short-Term Memory.</em> Neural Computation.</p>
<p>[3] Bai, S., Kolter, J. Z., &amp; Koltun, V. (2018). <em>An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling.</em></p>
<p>[4] Vaswani, A., et al.&nbsp;(2017). <em>Attention Is All You Need.</em> NeurIPS.</p>
<p>[5] Kipf, T. N., &amp; Welling, M. (2016). <em>Semi-Supervised Classification with Graph Convolutional Networks.</em></p>
<p>[6] Wu, Z., et al.&nbsp;(2019). <em>Graph WaveNet for Deep Spatial-Temporal Graph Modeling.</em></p>
</section>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>